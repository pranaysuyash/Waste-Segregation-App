import 'package:flutter_test/flutter_test.dart';\nimport 'package:waste_segregation_app/models/waste_classification.dart';\n\nvoid main() {\n  group('WasteClassification', () {\n    test('should create a WasteClassification with all required fields', () {\n      final classification = WasteClassification(\n        itemName: 'Test Item',\n        category: 'Dry Waste',\n        explanation: 'Test explanation',\n        disposalInstructions: DisposalInstructions(\n          primaryMethod: 'Test method',\n          steps: ['Test step'],\n          hasUrgentTimeframe: false,\n        ),\n        region: 'Test Region',\n        visualFeatures: ['test feature'],\n        alternatives: [],\n      );\n\n      expect(classification.itemName, 'Test Item');\n      expect(classification.category, 'Dry Waste');\n      expect(classification.explanation, 'Test explanation');\n      expect(classification.region, 'Test Region');\n      expect(classification.visualFeatures, hasLength(1));\n      expect(classification.alternatives, isEmpty);\n      expect(classification.id, isNotEmpty); // Auto-generated\n      expect(classification.timestamp, isA<DateTime>()); // Auto-generated\n    });\n\n    test('should create fallback classification', () {\n      final classification = WasteClassification.fallback('/path/to/image.jpg');\n\n      expect(classification.itemName, 'Unidentified Item');\n      expect(classification.category, 'Requires Manual Review');\n      expect(classification.subcategory, 'Classification Needed');\n      expect(classification.explanation, contains('unable to automatically identify'));\n      expect(classification.imageUrl, '/path/to/image.jpg');\n      expect(classification.confidence, 0.0);\n      expect(classification.clarificationNeeded, true);\n      expect(classification.riskLevel, 'unknown');\n      expect(classification.alternatives, hasLength(3));\n    });\n\n    test('should create WasteClassification from JSON', () {\n      final json = {\n        'id': 'test_json',\n        'itemName': 'Test Item',\n        'category': 'Dry Waste',\n        'explanation': 'Test explanation',\n        'region': 'Test Region',\n        'visualFeatures': ['feature1', 'feature2'],\n        'alternatives': [],\n        'confidence': 0.85,\n        'timestamp': '2024-01-15T10:30:00.000Z',\n      };\n\n      final classification = WasteClassification.fromJson(json);\n\n      expect(classification.id, 'test_json');\n      expect(classification.itemName, 'Test Item');\n      expect(classification.category, 'Dry Waste');\n      expect(classification.explanation, 'Test explanation');\n      expect(classification.region, 'Test Region');\n      expect(classification.visualFeatures, ['feature1', 'feature2']);\n      expect(classification.confidence, 0.85);\n      expect(classification.timestamp, DateTime.parse('2024-01-15T10:30:00.000Z'));\n    });\n\n    test('should handle copyWith correctly', () {\n      final original = WasteClassification(\n        itemName: 'Original Item',\n        category: 'Dry Waste',\n        explanation: 'Original explanation',\n        disposalInstructions: DisposalInstructions(\n          primaryMethod: 'Original method',\n          steps: ['Original step'],\n          hasUrgentTimeframe: false,\n        ),\n        region: 'Original Region',\n        visualFeatures: ['original'],\n        alternatives: [],\n        confidence: 0.5,\n      );\n\n      final updated = original.copyWith(\n        itemName: 'Updated Item',\n        confidence: 0.9,\n      );\n\n      expect(updated.itemName, 'Updated Item');\n      expect(updated.confidence, 0.9);\n      expect(updated.category, 'Dry Waste'); // Should remain unchanged\n      expect(updated.region, 'Original Region'); // Should remain unchanged\n      expect(updated.id, original.id); // Should remain unchanged\n    });\n  });\n\n  group('AlternativeClassification', () {\n    test('should create AlternativeClassification correctly', () {\n      final alternative = AlternativeClassification(\n        category: 'Wet Waste',\n        subcategory: 'Food Waste',\n        confidence: 0.7,\n        reason: 'Could be organic material',\n      );\n\n      expect(alternative.category, 'Wet Waste');\n      expect(alternative.subcategory, 'Food Waste');\n      expect(alternative.confidence, 0.7);\n      expect(alternative.reason, 'Could be organic material');\n    });\n\n    test('should create AlternativeClassification from JSON', () {\n      final json = {\n        'category': 'Hazardous Waste',\n        'subcategory': 'Electronic',\n        'confidence': 0.8,\n        'reason': 'Contains electronic components',\n      };\n\n      final alternative = AlternativeClassification.fromJson(json);\n\n      expect(alternative.category, 'Hazardous Waste');\n      expect(alternative.subcategory, 'Electronic');\n      expect(alternative.confidence, 0.8);\n      expect(alternative.reason, 'Contains electronic components');\n    });\n  });\n\n  group('DisposalInstructions', () {\n    test('should create DisposalInstructions correctly', () {\n      final instructions = DisposalInstructions(\n        primaryMethod: 'Recycling bin',\n        steps: ['Clean the item', 'Remove labels', 'Place in blue bin'],\n        hasUrgentTimeframe: false,\n        warnings: ['Ensure item is clean'],\n        tips: ['Check local recycling guidelines'],\n        timeframe: 'Next collection day',\n        location: 'Curbside recycling',\n        recyclingInfo: 'Can be recycled into new products',\n        estimatedTime: '2 minutes',\n      );\n\n      expect(instructions.primaryMethod, 'Recycling bin');\n      expect(instructions.steps, hasLength(3));\n      expect(instructions.hasUrgentTimeframe, false);\n      expect(instructions.warnings, contains('Ensure item is clean'));\n      expect(instructions.tips, contains('Check local recycling guidelines'));\n      expect(instructions.timeframe, 'Next collection day');\n      expect(instructions.location, 'Curbside recycling');\n      expect(instructions.recyclingInfo, 'Can be recycled into new products');\n      expect(instructions.estimatedTime, '2 minutes');\n    });\n\n    test('should create DisposalInstructions from JSON', () {\n      final json = {\n        'primaryMethod': 'Compost bin',\n        'steps': ['Remove any stickers', 'Cut into smaller pieces', 'Add to compost'],\n        'hasUrgentTimeframe': true,\n        'warnings': ['Do not include meat scraps'],\n        'tips': ['Mix with brown materials'],\n      };\n\n      final instructions = DisposalInstructions.fromJson(json);\n\n      expect(instructions.primaryMethod, 'Compost bin');\n      expect(instructions.steps, hasLength(3));\n      expect(instructions.hasUrgentTimeframe, true);\n      expect(instructions.warnings, hasLength(1));\n      expect(instructions.tips, hasLength(1));\n    });\n\n    test('should parse steps from string with various separators', () {\n      // Test comma separation\n      final commaSteps = DisposalInstructions.fromJson({\n        'primaryMethod': 'Test',\n        'steps': 'Step 1, Step 2, Step 3',\n        'hasUrgentTimeframe': false,\n      });\n      expect(commaSteps.steps, ['Step 1', 'Step 2', 'Step 3']);\n\n      // Test semicolon separation\n      final semicolonSteps = DisposalInstructions.fromJson({\n        'primaryMethod': 'Test',\n        'steps': 'Step 1; Step 2; Step 3',\n        'hasUrgentTimeframe': false,\n      });\n      expect(semicolonSteps.steps, ['Step 1', 'Step 2', 'Step 3']);\n    });\n\n    test('should handle invalid or empty steps gracefully', () {\n      final emptySteps = DisposalInstructions.fromJson({\n        'primaryMethod': 'Test',\n        'steps': '',\n        'hasUrgentTimeframe': false,\n      });\n      expect(emptySteps.steps, ['Please review manually']);\n\n      final nullSteps = DisposalInstructions.fromJson({\n        'primaryMethod': 'Test',\n        'steps': null,\n        'hasUrgentTimeframe': false,\n      });\n      expect(nullSteps.steps, ['Please review manually']);\n    });\n  });\n\n  group('WasteCategory Extensions', () {\n    test('should handle WasteCategory enum values', () {\n      final categories = [\n        WasteCategory.wet,\n        WasteCategory.dry,\n        WasteCategory.hazardous,\n        WasteCategory.medical,\n        WasteCategory.nonWaste,\n      ];\n\n      for (final category in categories) {\n        expect(category.name, isNotEmpty);\n        expect(category.description, isNotEmpty);\n        expect(category.color, isNotEmpty);\n      }\n    });\n\n    test('should handle WasteCategory properties', () {\n      expect(WasteCategory.wet.name, 'Wet Waste');\n      expect(WasteCategory.dry.name, 'Dry Waste');\n      expect(WasteCategory.hazardous.name, 'Hazardous Waste');\n      expect(WasteCategory.medical.name, 'Medical Waste');\n      expect(WasteCategory.nonWaste.name, 'Non-Waste');\n    });\n\n    test('should handle WasteCategory descriptions', () {\n      expect(WasteCategory.wet.description, contains('Biodegradable'));\n      expect(WasteCategory.dry.description, contains('Recyclable'));\n      expect(WasteCategory.hazardous.description, contains('dangerous'));\n      expect(WasteCategory.medical.description, contains('medical'));\n      expect(WasteCategory.nonWaste.description, contains('reused'));\n    });\n\n    test('should handle WasteCategory colors', () {\n      expect(WasteCategory.wet.color, '#4CAF50'); // Green\n      expect(WasteCategory.dry.color, '#FFC107'); // Amber\n      expect(WasteCategory.hazardous.color, '#FF5722'); // Deep Orange\n      expect(WasteCategory.medical.color, '#F44336'); // Red\n      expect(WasteCategory.nonWaste.color, '#9C27B0'); // Purple\n    });\n  });\n}\n