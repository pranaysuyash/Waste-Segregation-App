# Analytics Implementation Guide\n## Waste Segregation App\n\n**Date:** June 19, 2025  \n**Version:** 1.0  \n**Status:** Implementation Ready\n\n## Quick Start\n\n### 1. Basic Event Tracking\n\n```dart\n// In your screen or widget\nclass HomeScreen extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final analyticsService = ref.read(analyticsServiceProvider);\n    \n    // Track screen view\n    WidgetsBinding.instance.addPostFrameCallback((_) {\n      analyticsService.trackPageView(\n        'HomeScreen',\n        previousScreen: 'OnboardingScreen',\n        navigationMethod: 'button_tap',\n      );\n    });\n    \n    return Scaffold(\n      body: Column(\n        children: [\n          // Use analytics-aware buttons\n          AnalyticsElevatedButton(\n            elementId: 'classify_now_button',\n            screenName: 'HomeScreen',\n            userIntent: 'start_classification',\n            onPressed: () => _startClassification(),\n            child: Text('Classify Now'),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n### 2. Classification Tracking\n\n```dart\n// In your AI service or classification handler\nclass AIService {\n  final AnalyticsService _analytics;\n  \n  Future<ClassificationResult> classifyImage(String imagePath) async {\n    final stopwatch = Stopwatch()..start();\n    \n    try {\n      final result = await _performClassification(imagePath);\n      \n      // Track successful classification\n      await _analytics.trackFileClassified(\n        classificationId: result.id,\n        category: result.category,\n        confidenceScore: result.confidence,\n        processingDuration: stopwatch.elapsedMilliseconds,\n        modelVersion: 'v2.1',\n        method: 'standard', // or 'instant'\n        resultAccuracy: true,\n        additionalData: {\n          'image_size_bytes': await File(imagePath).length(),\n          'device_performance': _getDevicePerformanceMetrics(),\n        },\n      );\n      \n      return result;\n    } catch (e) {\n      // Track classification errors\n      await _analytics.trackClientError(\n        errorMessage: e.toString(),\n        screenName: 'ClassificationService',\n        userAction: 'classify_image',\n        additionalData: {\n          'image_path': imagePath,\n          'processing_duration_ms': stopwatch.elapsedMilliseconds,\n        },\n      );\n      rethrow;\n    }\n  }\n}\n```\n\n### 3. Performance Monitoring\n\n```dart\n// In your HTTP service\nclass ApiService {\n  final AnalyticsService _analytics;\n  \n  Future<Response> makeRequest(String endpoint, Map<String, dynamic> data) async {\n    final stopwatch = Stopwatch()..start();\n    \n    try {\n      final response = await http.post(\n        Uri.parse(endpoint),\n        body: jsonEncode(data),\n      );\n      \n      final latency = stopwatch.elapsedMilliseconds;\n      \n      if (response.statusCode != 200) {\n        // Track API errors\n        await _analytics.trackApiError(\n          endpoint: endpoint,\n          statusCode: response.statusCode,\n          latencyMs: latency,\n          errorMessage: response.body,\n        );\n      } else if (latency > 2000) {\n        // Track slow API responses\n        await _analytics.trackSlowResource(\n          operationName: 'api_request',\n          durationMs: latency,\n          resourceType: 'network',\n          additionalData: {\n            'endpoint': endpoint,\n            'response_size': response.body.length,\n          },\n        );\n      }\n      \n      return response;\n    } catch (e) {\n      await _analytics.trackApiError(\n        endpoint: endpoint,\n        statusCode: 0,\n        latencyMs: stopwatch.elapsedMilliseconds,\n        errorMessage: e.toString(),\n      );\n      rethrow;\n    }\n  }\n}\n```\n\n### 4. Gamification Events\n\n```dart\n// In your points/achievements service\nclass GamificationService {\n  final AnalyticsService _analytics;\n  \n  Future<void> awardPoints(String action, int points) async {\n    final user = await getCurrentUser();\n    final newTotal = user.totalPoints + points;\n    \n    // Update user points first\n    await updateUserPoints(user.id, newTotal);\n    \n    // Track points earned\n    await _analytics.trackPointsEarned(\n      pointsAmount: points,\n      sourceAction: action,\n      totalPoints: newTotal,\n      category: _getCategoryForAction(action),\n      additionalData: {\n        'user_level': user.level,\n        'streak_count': user.currentStreak,\n        'achievement_tier': user.achievementTier,\n      },\n    );\n    \n    // Check for level up\n    if (_checkLevelUp(user.level, newTotal)) {\n      await _analytics.trackEvent(\n        eventType: AnalyticsEventTypes.gamification,\n        eventName: AnalyticsEventNames.levelUp,\n        parameters: {\n          'old_level': user.level,\n          'new_level': user.level + 1,\n          'total_points': newTotal,\n        },\n      );\n    }\n  }\n}\n```\n\n### 5. Content Engagement\n\n```dart\n// In educational content screens\nclass EducationalContentScreen extends ConsumerStatefulWidget {\n  final String contentId;\n  \n  @override\n  ConsumerState<EducationalContentScreen> createState() => _EducationalContentScreenState();\n}\n\nclass _EducationalContentScreenState extends ConsumerState<EducationalContentScreen> {\n  late final Stopwatch _timeSpent;\n  late final AnalyticsService _analytics;\n  \n  @override\n  void initState() {\n    super.initState();\n    _timeSpent = Stopwatch()..start();\n    _analytics = ref.read(analyticsServiceProvider);\n    \n    // Track content view\n    WidgetsBinding.instance.addPostFrameCallback((_) {\n      _analytics.trackContentViewed(\n        contentId: widget.contentId,\n        contentType: 'educational_article',\n        source: 'navigation',\n        userLevel: ref.read(userProfileProvider).value?.level,\n      );\n    });\n  }\n  \n  @override\n  void dispose() {\n    // Track content completion\n    _analytics.trackContentCompleted(\n      contentId: widget.contentId,\n      timeSpentMs: _timeSpent.elapsedMilliseconds,\n      completionRate: _calculateCompletionRate(),\n    );\n    super.dispose();\n  }\n}\n```\n\n## Advanced Usage\n\n### 1. Custom Analytics Wrapper\n\n```dart\n// Wrap entire screens for automatic tracking\nclass AnalyticsScreenWrapper extends ConsumerWidget {\n  final Widget child;\n  final String screenName;\n  final String? previousScreen;\n  \n  const AnalyticsScreenWrapper({\n    super.key,\n    required this.child,\n    required this.screenName,\n    this.previousScreen,\n  });\n  \n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final analytics = ref.read(analyticsServiceProvider);\n    \n    // Track screen view\n    WidgetsBinding.instance.addPostFrameCallback((_) {\n      analytics.trackPageView(\n        screenName,\n        previousScreen: previousScreen,\n      );\n    });\n    \n    return AnalyticsTrackingWrapper(\n      screenName: screenName,\n      trackScrollDepth: true,\n      trackRageClicks: true,\n      child: child,\n    );\n  }\n}\n```\n\n### 2. Batch Event Processing\n\n```dart\n// For high-frequency events, batch them\nclass AnalyticsBatcher {\n  final AnalyticsService _analytics;\n  final List<Map<String, dynamic>> _batchedEvents = [];\n  Timer? _flushTimer;\n  \n  void addEvent(String eventType, String eventName, Map<String, dynamic> parameters) {\n    _batchedEvents.add({\n      'eventType': eventType,\n      'eventName': eventName,\n      'parameters': parameters,\n      'timestamp': DateTime.now().toIso8601String(),\n    });\n    \n    // Flush every 10 events or 30 seconds\n    if (_batchedEvents.length >= 10) {\n      _flushEvents();\n    } else {\n      _scheduleFlush();\n    }\n  }\n  \n  void _scheduleFlush() {\n    _flushTimer?.cancel();\n    _flushTimer = Timer(Duration(seconds: 30), _flushEvents);\n  }\n  \n  void _flushEvents() {\n    if (_batchedEvents.isEmpty) return;\n    \n    final events = List.from(_batchedEvents);\n    _batchedEvents.clear();
    _flushTimer?.cancel();\n    \n    // Send batch to analytics service\n    for (final event in events) {\n      _analytics.trackEvent(\n        eventType: event['eventType'],\n        eventName: event['eventName'],\n        parameters: event['parameters'],\n      );\n    }\n  }\n}\n```\n\n### 3. A/B Testing Integration\n\n```dart\n// Track A/B test participation\nclass ABTestingService {\n  final AnalyticsService _analytics;\n  \n  Future<String> getVariant(String experimentId) async {\n    final variant = await _determineVariant(experimentId);\n    \n    // Track experiment participation\n    await _analytics.trackEvent(\n      eventType: AnalyticsEventTypes.experiment,\n      eventName: 'experiment_assigned',\n      parameters: {\n        'experiment_id': experimentId,\n        'variant': variant,\n        'assignment_method': 'random',\n      },\n    );\n    \n    return variant;\n  }\n  \n  Future<void> trackConversion(String experimentId, String variant, String goalEvent) async {\n    await _analytics.trackEvent(\n      eventType: AnalyticsEventTypes.experiment,\n      eventName: 'experiment_conversion',\n      parameters: {\n        'experiment_id': experimentId,\n        'variant': variant,\n        'goal_event': goalEvent,\n      },\n    );\n  }\n}\n```\n\n## Best Practices\n\n### 1. Event Naming\n- Use snake_case for event names\n- Follow object_action pattern: `file_classified`, `button_clicked`\n- Be specific but concise: `recycling_guide_completed` vs `content_completed`\n\n### 2. Parameter Structure\n- Include context: screen_name, user_level, session_id\n- Use consistent units: always milliseconds for duration, always percentages for rates\n- Avoid PII: no emails, phone numbers, or personal identifiers\n\n### 3. Performance Considerations\n- Don't track too frequently (max 1 event per second per user)\n- Batch high-frequency events\n- Use background processing for heavy analytics operations\n\n### 4. Privacy Compliance\n- Always check consent before tracking\n- Provide clear opt-out mechanisms\n- Anonymize sensitive data\n\n### 5. Testing\n- Use analytics mocks in tests\n- Verify events are properly formatted\n- Test consent scenarios\n\n## Common Patterns\n\n### Screen Navigation Tracking\n```dart\n// In your navigation service or route observer\nclass AnalyticsRouteObserver extends RouteObserver<PageRoute<dynamic>> {\n  final AnalyticsService _analytics;\n  \n  @override\n  void didPop(Route<dynamic> route, Route<dynamic>? previousRoute) {\n    super.didPop(route, previousRoute);\n    _trackNavigation(route, previousRoute, 'pop');\n  }\n  \n  @override\n  void didPush(Route<dynamic> route, Route<dynamic>? previousRoute) {\n    super.didPush(route, previousRoute);\n    _trackNavigation(route, previousRoute, 'push');\n  }\n  \n  void _trackNavigation(Route route, Route? previousRoute, String method) {\n    final routeName = route.settings.name ?? 'unknown';\n    final previousName = previousRoute?.settings.name;\n    \n    _analytics.trackPageView(\n      routeName,\n      previousScreen: previousName,\n      navigationMethod: method,\n    );\n  }\n}\n```\n\n### Error Boundary Analytics\n```dart\n// Wrap your app with error tracking\nclass AnalyticsErrorBoundary extends StatefulWidget {\n  final Widget child;\n  \n  @override\n  State<AnalyticsErrorBoundary> createState() => _AnalyticsErrorBoundaryState();\n}\n\nclass _AnalyticsErrorBoundaryState extends State<AnalyticsErrorBoundary> {\n  @override\n  void initState() {\n    super.initState();\n    \n    // Catch Flutter errors\n    FlutterError.onError = (FlutterErrorDetails details) {\n      final analytics = ProviderScope.containerOf(context).read(analyticsServiceProvider);\n      analytics.trackClientError(\n        errorMessage: details.exception.toString(),\n        screenName: 'FlutterFramework',\n        stackTrace: details.stack.toString(),\n      );\n      FlutterError.presentError(details);\n    };\n  }\n  \n  @override\n  Widget build(BuildContext context) => widget.child;\n}\n```\n\n## Troubleshooting\n\n### Events Not Showing Up\n1. Check consent settings\n2. Verify internet connection\n3. Check Firebase configuration\n4. Validate event schema\n\n### Performance Issues\n1. Reduce event frequency\n2. Implement batching\n3. Check for infinite loops in tracking code\n4. Monitor memory usage\n\n### Privacy Compliance Issues\n1. Audit for PII in event parameters\n2. Implement proper consent flows\n3. Provide data deletion mechanisms\n4. Document data retention policies\n\n## Next Steps\n\n1. **Integration**: Start with basic screen tracking\n2. **Validation**: Run analytics in debug mode first\n3. **Rollout**: Gradual deployment with feature flags\n4. **Optimization**: Monitor performance and adjust\n5. **Analysis**: Set up dashboards and alerts\n\nFor questions or issues, refer to the main tracking plan document or contact the development team. 