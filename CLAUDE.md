# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a comprehensive Flutter application for AI-powered waste classification and environmental education. The app uses multiple AI models (primarily OpenAI GPT, with Gemini fallback) to identify items and classify them into waste categories: Wet Waste, Dry Waste, Hazardous Waste, Medical Waste, and Non-Waste.

## Development Commands

### Core Flutter Commands
```bash
# Install dependencies
flutter pub get

# Generate model code (required for Hive serialization)
flutter pub run build_runner build

# Run the app with environment variables
flutter run --dart-define-from-file=.env

# Validated run with error checking (recommended)
./scripts/development/run_with_env.sh

# Run linting
flutter analyze

# Run tests
flutter test

# Update golden test files
flutter test --update-goldens
```

### Build Commands
```bash
# Android APK
flutter build apk --release --dart-define-from-file=.env

# Android App Bundle (Play Store)
flutter build appbundle --release --dart-define-from-file=.env

# iOS (requires macOS)
flutter build ios --release --dart-define-from-file=.env
```

### Testing Commands
```bash
# Run all tests
flutter test

# Run specific test file
flutter test test/models/waste_classification_test.dart

# Run tests with coverage
flutter test --coverage

# Run integration tests (currently disabled)
# flutter test integration_test/

# Run Patrol E2E tests
patrol test
```

### Code Generation and Maintenance
```bash
# Generate Hive adapters and JSON serialization
flutter pub run build_runner build --delete-conflicting-outputs

# Clean and rebuild
flutter clean && flutter pub get && flutter pub run build_runner build

# Fix common Dart/Flutter issues
dart fix --apply
```

## Architecture Overview

### State Management
- **Primary**: Provider pattern for most state management
- **Secondary**: Riverpod for specific providers (app_providers.dart)
- **Local Storage**: Hive for offline data persistence
- **Cloud Sync**: Firebase Firestore for real-time data synchronization

### Core Services Architecture

#### AI Classification System
- **AIService** (`lib/services/ai_service.dart`): Multi-tier AI system with OpenAI (primary) and Gemini (fallback)
- **CacheService**: SHA-256 based image classification caching
- **ResultPipeline**: Processes classification results and handles saving

#### Storage Architecture
- **StorageService**: Hive-based local storage for classifications, user profiles, gamification data
- **EnhancedStorageService**: Extended storage with thumbnail generation and migration support
- **CloudStorageService**: Firebase Firestore integration for real-time sync
- **GoogleDriveService**: Optional full backup/restore via Google Drive

#### Gamification System
- **GamificationService**: Points, achievements, challenges, and streak tracking
- **PointsEngine**: Core points calculation and distribution logic
- **PointsEngineProvider**: Provider wrapper for points management

#### Content and Community
- **EducationalContentService**: Manages articles, videos, quizzes about waste segregation
- **CommunityService**: Handles shared classifications and community features
- **DisposalInstructionsService**: Provides disposal guidance for classified items

### Key Models and Data Structure

#### Core Models (`lib/models/`)
- **WasteClassification**: Primary data model for AI classification results
- **UserProfile**: User settings, preferences, and gamification progress
- **Gamification**: Points, achievements, streaks, and challenge data
- **EducationalContent**: Articles, videos, and quizzes
- **CachedClassification**: Local caching for repeated image analysis

#### Generated Models
All models ending in `.g.dart` are auto-generated by `build_runner` for Hive serialization and JSON handling.

### Screen Architecture

#### Navigation Structure
- **MainNavigationWrapper**: Bottom navigation with Home, History, Settings
- **GlobalMenuWrapper**: Consistent app bar and navigation across screens
- **NavigationSettingsService**: Manages navigation preferences and behavior

#### Core Screens (`lib/screens/`)
- **AuthScreen**: Google Sign-in and guest mode
- **HomeScreen/ModernHomeScreen**: Main classification interface with camera/gallery
- **ResultScreen**: Shows AI classification results with disposal instructions
- **HistoryScreen**: Past classifications with filtering and search
- **AchievementsScreen**: Gamification progress and badges
- **SettingsScreen**: App preferences and account management

## Environment Setup

### Required Environment Variables (.env file)
```bash
OPENAI_API_KEY=your_openai_api_key_here
GEMINI_API_KEY=your_gemini_api_key_here
OPENAI_API_MODEL_PRIMARY=gpt-4.1-nano
OPENAI_API_MODEL_SECONDARY=gpt-4o-mini
OPENAI_API_MODEL_TERTIARY=gpt-4.1-mini
GEMINI_API_MODEL=gemini-2.0-flash
```

### Firebase Configuration
- Requires `google-services.json` (Android) and `GoogleService-Info.plist` (iOS)
- Enable Firestore, Authentication, Crashlytics, Performance, and Storage
- Firestore indexes are defined in `firestore.indexes.json`

### Development Dependencies
- Flutter SDK 3.5.0+
- Dart SDK 3.5.0+
- Android Studio/Xcode for mobile development
- Node.js for Storybook testing framework

## Important Implementation Notes

### AI Service Integration
The app uses a 4-tier fallback system for AI classification:
1. OpenAI GPT-4.1-nano (primary)
2. OpenAI GPT-4o-mini (secondary) 
3. OpenAI GPT-4.1-mini (tertiary)
4. Google Gemini 2.0-flash (final fallback)

### State Management Patterns
- Use Provider for most UI state and service management
- Use Riverpod providers in `app_providers.dart` for dependency injection
- Services are injected through MultiProvider in main.dart
- Local state uses Hive for persistence, cloud state syncs via Firestore

### Image Handling
- Uses `image_picker` for camera/gallery access
- Generates thumbnails via `enhanced_storage_service.dart`
- Implements SHA-256 based caching to avoid re-analyzing identical images
- Supports both local storage and optional cloud backup

### Testing Strategy
- Unit tests for models and services in `test/` directory
- Widget tests with golden file testing for UI consistency
- Patrol framework for E2E testing (integration_test_disabled/ when needed)
- Comprehensive UI overflow and accessibility testing

### Code Quality and Linting
- Strict linting rules defined in `analysis_options.yaml`
- Emphasis on const constructors, final variables, and performance optimization
- Print statements should use `WasteAppLogger` instead of `print()` or `debugPrint()`
- Follow Flutter best practices for state management and widget composition

## Common Development Tasks

### Adding New AI Models
1. Update AIService with new model configuration
2. Add model constants to `utils/constants.dart`
3. Update environment variable documentation
4. Test fallback behavior in AI service tests

### Adding New Waste Categories
1. Update WasteClassification model
2. Run `flutter pub run build_runner build` to regenerate adapters
3. Update disposal instructions in DisposalInstructionsService
4. Add educational content for new category

### Implementing New Gamification Features
1. Update Gamification model for new achievement types
2. Implement logic in GamificationService
3. Update PointsEngine for new point calculations
4. Add UI components in achievements screen

### Database Schema Changes
1. Update Firestore security rules in `firestore.rules`
2. Update indexes in `firestore.indexes.json`
3. Deploy changes: `firebase deploy --only firestore`
4. Test migration in development environment

### Performance Optimization
- Use FramePerformanceMonitor for identifying UI performance issues
- Implement lazy loading for large lists (history, educational content)
- Cache frequently accessed data with appropriate invalidation strategies
- Monitor memory usage, especially for image handling and storage services

## Critical Analysis Findings (2025-06-23)

### Comprehensive App Analysis Summary
A comprehensive multi-agent analysis was performed covering Design/UI, Security, Performance, DevOps, Architecture, and Documentation. Key findings:

#### 🚨 Critical Issues Identified
1. **iOS Network Security**: `NSAllowsArbitraryLoads: true` allows unencrypted connections
2. **Test Suite Failures**: 21 test suites failing due to compilation errors
3. **Empty Catch Blocks**: Silent error handling in 3 locations
4. **Non-null Assertions**: Unsafe assertions without proper null checks

#### 🔧 Technical Debt
1. **Duplicate Home Screens**: 4+ different implementations causing confusion
2. **Incomplete Localization**: TODO comments in dialog helper
3. **Missing Firestore Queries**: Incomplete token provider implementation
4. **Documentation Drift**: 50+ root directory docs, broken links, version conflicts

#### ⚡ Performance Opportunities
1. **Firestore Optimization**: 40% cost reduction via write batching
2. **Memory Leak Fixes**: AI service resource disposal improvements
3. **UI Performance**: RepaintBoundary additions for smoother scrolling
4. **Query Optimization**: Pagination implementation needed

#### 📊 Architecture Strengths
1. **Sophisticated AI System**: 4-tier fallback with comprehensive caching
2. **Security Foundation**: Excellent Firestore rules and data isolation
3. **Feature Completeness**: 85%+ implementation across all major features
4. **Testing Infrastructure**: 143 test files with multiple test types

### Immediate Action Plan
See `docs/IMMEDIATE_ACTION_ITEMS.md` for detailed priority matrix and implementation timeline.

### Analysis Reports Generated
- `docs/UI_UX_ANALYSIS_REPORT.md` - Design system and accessibility review
- `docs/SECURITY_AUDIT_REPORT.md` - Vulnerability assessment and privacy compliance
- `docs/PERFORMANCE_ANALYSIS_REPORT.md` - Bottlenecks and optimization opportunities
- `docs/DEVOPS_TESTING_REPORT.md` - CI/CD pipeline and test infrastructure
- `docs/FEATURE_ARCHITECTURE_REPORT.md` - Feature completeness and scalability
- `docs/STORAGE_OPTIMIZATION_REPORT.md` - Database and cost optimization
- `docs/DOCUMENTATION_ANALYSIS_REPORT.md` - Documentation quality and maintenance
- `docs/IMMEDIATE_ACTION_ITEMS.md` - Prioritized task list with timelines

### Key Metrics
- **Current Monthly Cost**: $47-90 (API + Firebase)
- **Optimized Cost Projection**: $25-54 (43% savings)
- **Test Coverage**: 55% (143 tests / 260 source files)
- **Architecture Quality**: A- (8.5/10)
- **Security Rating**: Moderate (critical fixes needed)

## Documentation Analysis & Maintenance (2025-06-23)

### Documentation Quality Assessment
A comprehensive analysis of 300+ markdown files revealed extensive documentation coverage with significant maintenance debt:

#### 📊 Documentation Statistics
- **Total MD Files**: 300+ across root and /docs directories
- **Root Directory Pollution**: 50+ files needing organization
- **Broken Links**: 15+ identified requiring fixes
- **Version Conflicts**: Multiple conflicting version references
- **Documentation Quality**: B+ (good coverage, needs maintenance)

#### 🚨 Critical Documentation Issues
1. **AI Model Discrepancy**: README claims Gemini primary, code uses GPT-4.1-nano
2. **Environment Variable Conflicts**: Docs use different variable names than code
3. **Data Sync Misrepresentation**: Docs claim Google Drive primary, Firestore is actual primary
4. **Outdated Feature Status**: Completed features still marked as "in progress"

#### 📋 New TODOs from Documentation Analysis
**Priority 1 (Critical - This Week):**
- Fix AI model information in root README.md
- Align environment variable documentation with code
- Correct data sync architecture description
- Consolidate conflicting version numbers

**Priority 2 (Organization - 2 Weeks):**
- Fix 15+ broken internal links
- Move root directory docs to /docs subdirectories
- Remove outdated configuration instructions
- Consolidate duplicate content

**Priority 3 (Enhancement - 1 Month):**
- Create comprehensive API documentation
- Write deployment and CI/CD guides
- Document architecture with diagrams
- Create developer onboarding guide

#### 🔧 Documentation Maintenance Process
To prevent future documentation debt:
1. **Documentation as Code**: Update docs with every code change
2. **Monthly Review Cycles**: Regular documentation audits
3. **Automated Link Checking**: Prevent broken references
4. **Single Source of Truth**: Eliminate conflicting information

#### 📁 Recommended Documentation Structure
```
docs/
├── guides/           # User and developer guides
├── api/             # API documentation  
├── architecture/    # System design and diagrams
├── deployment/      # Deployment and CI/CD
├── testing/         # Testing documentation
├── planning/        # Roadmaps and planning
├── fixes/           # Bug fixes (archived after completion)
└── archive/         # Historical documentation
```

#### 🎯 Documentation Success Metrics
- **Immediate (1 month)**: Zero critical discrepancies, all broken links fixed
- **Medium-term (3 months)**: 90% reduction in root directory files, comprehensive API docs
- **Long-term (6 months)**: Automated quality checks, sustainable maintenance process

The documentation analysis reveals that while the project has excellent documentation coverage, implementing a structured maintenance process is critical for long-term sustainability and developer productivity.